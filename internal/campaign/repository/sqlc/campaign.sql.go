// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: campaign.sql

package sqlc

import (
	"context"
	"database/sql"
	"time"

	"github.com/google/uuid"
	"github.com/lib/pq"
	"github.com/sqlc-dev/pqtype"
)

const createCampaign = `-- name: CreateCampaign :one
INSERT INTO campaigns (title, description, slug, user_id, target_amount, start_date, end_date, status, images, created_at, updated_at)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP)
RETURNING id, title, description, slug, user_id, target_amount, current_amount, start_date, end_date, status, created_at, updated_at, deleted_at, images
`

type CreateCampaignParams struct {
	Title        string    `json:"title"`
	Description  *string   `json:"description"`
	Slug         string    `json:"slug"`
	UserID       int32     `json:"user_id"`
	TargetAmount *float32  `json:"target_amount"`
	StartDate    time.Time `json:"start_date"`
	EndDate      time.Time `json:"end_date"`
	Status       int32     `json:"status"`
	Images       []string  `json:"images"`
}

func (q *Queries) CreateCampaign(ctx context.Context, arg CreateCampaignParams) (Campaign, error) {
	row := q.db.QueryRowContext(ctx, createCampaign,
		arg.Title,
		arg.Description,
		arg.Slug,
		arg.UserID,
		arg.TargetAmount,
		arg.StartDate,
		arg.EndDate,
		arg.Status,
		pq.Array(arg.Images),
	)
	var i Campaign
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Description,
		&i.Slug,
		&i.UserID,
		&i.TargetAmount,
		&i.CurrentAmount,
		&i.StartDate,
		&i.EndDate,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		pq.Array(&i.Images),
	)
	return i, err
}

const createDonation = `-- name: CreateDonation :one
INSERT INTO donations (donatur_id, campaign_id, amount, note)
VALUES ($1, $2, $3, $4) RETURNING id, donatur_id, campaign_id, amount, note, created_at, updated_at
`

type CreateDonationParams struct {
	DonaturID  int32          `json:"donatur_id"`
	CampaignID int32          `json:"campaign_id"`
	Amount     string         `json:"amount"`
	Note       sql.NullString `json:"note"`
}

func (q *Queries) CreateDonation(ctx context.Context, arg CreateDonationParams) (Donation, error) {
	row := q.db.QueryRowContext(ctx, createDonation,
		arg.DonaturID,
		arg.CampaignID,
		arg.Amount,
		arg.Note,
	)
	var i Donation
	err := row.Scan(
		&i.ID,
		&i.DonaturID,
		&i.CampaignID,
		&i.Amount,
		&i.Note,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createDonatur = `-- name: CreateDonatur :one
INSERT INTO donaturs (name, email, user_id, campaign_id)
VALUES ($1, $2, $3, $4) RETURNING id, user_id, campaign_id, name, email, created_at, updated_at
`

type CreateDonaturParams struct {
	Name       string         `json:"name"`
	Email      sql.NullString `json:"email"`
	UserID     int32          `json:"user_id"`
	CampaignID int32          `json:"campaign_id"`
}

func (q *Queries) CreateDonatur(ctx context.Context, arg CreateDonaturParams) (Donatur, error) {
	row := q.db.QueryRowContext(ctx, createDonatur,
		arg.Name,
		arg.Email,
		arg.UserID,
		arg.CampaignID,
	)
	var i Donatur
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.CampaignID,
		&i.Name,
		&i.Email,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createPayment = `-- name: CreatePayment :one
INSERT INTO payments (transaction_id, donatur_id, donation_id, campaign_id, amount, link, note, status)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8)
RETURNING id, transaction_id, donatur_id, donation_id, campaign_id, vendor, method, amount, link, note, status, response, payment_date, created_at, updated_at
`

type CreatePaymentParams struct {
	TransactionID uuid.UUID      `json:"transaction_id"`
	DonaturID     int32          `json:"donatur_id"`
	DonationID    int32          `json:"donation_id"`
	CampaignID    int32          `json:"campaign_id"`
	Amount        string         `json:"amount"`
	Link          sql.NullString `json:"link"`
	Note          sql.NullString `json:"note"`
	Status        int32          `json:"status"`
}

func (q *Queries) CreatePayment(ctx context.Context, arg CreatePaymentParams) (Payment, error) {
	row := q.db.QueryRowContext(ctx, createPayment,
		arg.TransactionID,
		arg.DonaturID,
		arg.DonationID,
		arg.CampaignID,
		arg.Amount,
		arg.Link,
		arg.Note,
		arg.Status,
	)
	var i Payment
	err := row.Scan(
		&i.ID,
		&i.TransactionID,
		&i.DonaturID,
		&i.DonationID,
		&i.CampaignID,
		&i.Vendor,
		&i.Method,
		&i.Amount,
		&i.Link,
		&i.Note,
		&i.Status,
		&i.Response,
		&i.PaymentDate,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const donate = `-- name: Donate :exec
UPDATE campaigns
SET current_amount = current_amount + $2::numeric	
WHERE id = $1 AND deleted_at IS NULL
`

type DonateParams struct {
	ID     int32  `json:"id"`
	Amount string `json:"amount"`
}

func (q *Queries) Donate(ctx context.Context, arg DonateParams) error {
	_, err := q.db.ExecContext(ctx, donate, arg.ID, arg.Amount)
	return err
}

const findCampaignByIdForUpdate = `-- name: FindCampaignByIdForUpdate :one
SELECT id, user_id FROM campaigns
WHERE id = $1 AND deleted_at IS NULL
FOR UPDATE
`

type FindCampaignByIdForUpdateRow struct {
	ID     int32 `json:"id"`
	UserID int32 `json:"user_id"`
}

func (q *Queries) FindCampaignByIdForUpdate(ctx context.Context, id int32) (FindCampaignByIdForUpdateRow, error) {
	row := q.db.QueryRowContext(ctx, findCampaignByIdForUpdate, id)
	var i FindCampaignByIdForUpdateRow
	err := row.Scan(&i.ID, &i.UserID)
	return i, err
}

const findCampaignsBySlugForUpdate = `-- name: FindCampaignsBySlugForUpdate :one
SELECT id, user_id FROM campaigns
WHERE slug = $1 AND deleted_at IS NULL
FOR UPDATE
`

type FindCampaignsBySlugForUpdateRow struct {
	ID     int32 `json:"id"`
	UserID int32 `json:"user_id"`
}

func (q *Queries) FindCampaignsBySlugForUpdate(ctx context.Context, slug string) (FindCampaignsBySlugForUpdateRow, error) {
	row := q.db.QueryRowContext(ctx, findCampaignsBySlugForUpdate, slug)
	var i FindCampaignsBySlugForUpdateRow
	err := row.Scan(&i.ID, &i.UserID)
	return i, err
}

const getCampaignBySlug = `-- name: GetCampaignBySlug :one
SELECT campaigns.id, campaigns.title, campaigns.description, campaigns.slug, campaigns.target_amount, campaigns.current_amount, campaigns.start_date, campaigns.end_date,
	users.name as user_name, users.email as user_email,
	CASE 
		WHEN campaigns.current_amount = 0 THEN 0 
		ELSE campaigns.target_amount / campaigns.current_amount 
	END::DECIMAL(10, 2) AS progress
FROM campaigns
JOIN users ON campaigns.user_id = users.id
WHERE campaigns.slug = $1
`

type GetCampaignBySlugRow struct {
	ID            int32     `json:"id"`
	Title         string    `json:"title"`
	Description   *string   `json:"description"`
	Slug          string    `json:"slug"`
	TargetAmount  *float32  `json:"target_amount"`
	CurrentAmount *float32  `json:"current_amount"`
	StartDate     time.Time `json:"start_date"`
	EndDate       time.Time `json:"end_date"`
	UserName      string    `json:"user_name"`
	UserEmail     string    `json:"user_email"`
	Progress      string    `json:"progress"`
}

func (q *Queries) GetCampaignBySlug(ctx context.Context, slug string) (GetCampaignBySlugRow, error) {
	row := q.db.QueryRowContext(ctx, getCampaignBySlug, slug)
	var i GetCampaignBySlugRow
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Description,
		&i.Slug,
		&i.TargetAmount,
		&i.CurrentAmount,
		&i.StartDate,
		&i.EndDate,
		&i.UserName,
		&i.UserEmail,
		&i.Progress,
	)
	return i, err
}

const getCampaignTotalPaidDonaturs = `-- name: GetCampaignTotalPaidDonaturs :one
SELECT COUNT(*) AS total FROM donaturs
WHERE donaturs.campaign_id IN (
        SELECT id FROM campaigns WHERE slug  = $1 AND deleted_at IS NULL 
    ) 
	AND EXISTS (
		SELECT 1 FROM payments
		WHERE status = 5 AND donatur_id = donaturs.id
	)
`

func (q *Queries) GetCampaignTotalPaidDonaturs(ctx context.Context, slug string) (int64, error) {
	row := q.db.QueryRowContext(ctx, getCampaignTotalPaidDonaturs, slug)
	var total int64
	err := row.Scan(&total)
	return total, err
}

const getCampaigns = `-- name: GetCampaigns :many
SELECT id, title, slug,
		current_amount, target_amount,
	   CASE 
		   WHEN current_amount = 0 THEN 0 
		   ELSE target_amount / current_amount 
	   END::DECIMAL(10, 2) AS progress, 
	   start_date, end_date,
	   CASE
	   	   	WHEN status = 0 THEN 'Draft'
	   	   	WHEN status = 1 THEN 'Active'
	   	   	WHEN status = 2 THEN 'Completed'
	   	   	WHEN status = 3 THEN 'Cancelled'
	   	   ELSE 'Unknown'
	   END AS status
FROM campaigns
WHERE 
	deleted_at IS NULL AND
	status = 1 AND
	start_date <= CURRENT_TIMESTAMP AND
	end_date >= CURRENT_TIMESTAMP
ORDER BY start_date DESC
LIMIT $1 OFFSET $2
`

type GetCampaignsParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

type GetCampaignsRow struct {
	ID            int32     `json:"id"`
	Title         string    `json:"title"`
	Slug          string    `json:"slug"`
	CurrentAmount *float32  `json:"current_amount"`
	TargetAmount  *float32  `json:"target_amount"`
	Progress      string    `json:"progress"`
	StartDate     time.Time `json:"start_date"`
	EndDate       time.Time `json:"end_date"`
	Status        string    `json:"status"`
}

func (q *Queries) GetCampaigns(ctx context.Context, arg GetCampaignsParams) ([]GetCampaignsRow, error) {
	rows, err := q.db.QueryContext(ctx, getCampaigns, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetCampaignsRow
	for rows.Next() {
		var i GetCampaignsRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Slug,
			&i.CurrentAmount,
			&i.TargetAmount,
			&i.Progress,
			&i.StartDate,
			&i.EndDate,
			&i.Status,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPaginatedDonaturs = `-- name: GetPaginatedDonaturs :many
SELECT 
	d.id, 
	d.name, 
	COALESCE(d.email, '') AS email,
	p.amount::real AS total_donated
FROM donaturs d
JOIN (
	SELECT donatur_id, SUM(amount) AS amount
	FROM donations
	GROUP BY donatur_id
) p ON d.id = p.donatur_id
WHERE d.campaign_id = (
	SELECT id FROM campaigns WHERE slug = $1 AND deleted_at IS NULL LIMIT 1
)
AND EXISTS (
	SELECT 1 FROM payments
	WHERE status = 5 AND donatur_id = d.id
)
ORDER BY d.created_at DESC
LIMIT $2 OFFSET $3
`

type GetPaginatedDonatursParams struct {
	Slug   string `json:"slug"`
	Limit  int32  `json:"limit"`
	Offset int32  `json:"offset"`
}

type GetPaginatedDonatursRow struct {
	ID           int32   `json:"id"`
	Name         string  `json:"name"`
	Email        string  `json:"email"`
	TotalDonated float32 `json:"total_donated"`
}

func (q *Queries) GetPaginatedDonaturs(ctx context.Context, arg GetPaginatedDonatursParams) ([]GetPaginatedDonatursRow, error) {
	rows, err := q.db.QueryContext(ctx, getPaginatedDonaturs, arg.Slug, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetPaginatedDonatursRow
	for rows.Next() {
		var i GetPaginatedDonatursRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Email,
			&i.TotalDonated,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPaginatedUserCampaign = `-- name: GetPaginatedUserCampaign :many
SELECT id, title, images,
	   CASE 
		   WHEN current_amount = 0 THEN 0 
		   ELSE target_amount / current_amount 
	   END::DECIMAL(10, 2) AS progress, 
	   start_date, end_date, status,
	   CASE
	   	   	WHEN status = 0 THEN 'Draft'
	   	   	WHEN status = 1 THEN 'Active'
	   	   	WHEN status = 2 THEN 'Completed'
	   	   	WHEN status = 3 THEN 'Cancelled'
	   	   ELSE 'Unknown'
	   END AS status_label
FROM campaigns
WHERE 
	user_id = $1 AND
	deleted_at IS NULL AND
	title ILIKE '%' || $4::text || '%' AND
	status = $5::integer
ORDER BY start_date DESC
LIMIT $2 OFFSET $3
`

type GetPaginatedUserCampaignParams struct {
	UserID int32  `json:"user_id"`
	Limit  int32  `json:"limit"`
	Offset int32  `json:"offset"`
	Title  string `json:"title"`
	Status int32  `json:"status"`
}

type GetPaginatedUserCampaignRow struct {
	ID          int32     `json:"id"`
	Title       string    `json:"title"`
	Images      []string  `json:"images"`
	Progress    string    `json:"progress"`
	StartDate   time.Time `json:"start_date"`
	EndDate     time.Time `json:"end_date"`
	Status      int32     `json:"status"`
	StatusLabel string    `json:"status_label"`
}

func (q *Queries) GetPaginatedUserCampaign(ctx context.Context, arg GetPaginatedUserCampaignParams) ([]GetPaginatedUserCampaignRow, error) {
	rows, err := q.db.QueryContext(ctx, getPaginatedUserCampaign,
		arg.UserID,
		arg.Limit,
		arg.Offset,
		arg.Title,
		arg.Status,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetPaginatedUserCampaignRow
	for rows.Next() {
		var i GetPaginatedUserCampaignRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			pq.Array(&i.Images),
			&i.Progress,
			&i.StartDate,
			&i.EndDate,
			&i.Status,
			&i.StatusLabel,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPaymentByTransactionId = `-- name: GetPaymentByTransactionId :one
SELECT id, transaction_id, donatur_id, donation_id, campaign_id, vendor, method, amount, link, note, status, response, payment_date, created_at, updated_at FROM payments WHERE transaction_id = $1
`

func (q *Queries) GetPaymentByTransactionId(ctx context.Context, transactionID uuid.UUID) (Payment, error) {
	row := q.db.QueryRowContext(ctx, getPaymentByTransactionId, transactionID)
	var i Payment
	err := row.Scan(
		&i.ID,
		&i.TransactionID,
		&i.DonaturID,
		&i.DonationID,
		&i.CampaignID,
		&i.Vendor,
		&i.Method,
		&i.Amount,
		&i.Link,
		&i.Note,
		&i.Status,
		&i.Response,
		&i.PaymentDate,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getTotalCampaigns = `-- name: GetTotalCampaigns :one
SELECT COUNT(*) AS total
FROM campaigns
WHERE 
	deleted_at IS NULL AND
	status = 1 AND
	start_date <= CURRENT_TIMESTAMP AND
	end_date >= CURRENT_TIMESTAMP
`

func (q *Queries) GetTotalCampaigns(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, getTotalCampaigns)
	var total int64
	err := row.Scan(&total)
	return total, err
}

const getTotalUserCampaigns = `-- name: GetTotalUserCampaigns :one
SELECT COUNT(*) AS total
FROM campaigns
WHERE 
	user_id = $1 AND
	deleted_at IS NULL AND
	title ILIKE '%' || $2::text || '%' AND
	status = $3::integer
`

type GetTotalUserCampaignsParams struct {
	UserID int32  `json:"user_id"`
	Title  string `json:"title"`
	Status int32  `json:"status"`
}

func (q *Queries) GetTotalUserCampaigns(ctx context.Context, arg GetTotalUserCampaignsParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, getTotalUserCampaigns, arg.UserID, arg.Title, arg.Status)
	var total int64
	err := row.Scan(&total)
	return total, err
}

const getUserCampaignById = `-- name: GetUserCampaignById :one
SELECT id, title, description, slug, user_id, target_amount, current_amount, start_date, end_date, status,
	   created_at::TIMESTAMP, updated_at::TIMESTAMP
FROM campaigns
WHERE id = $1 AND user_id = $2
`

type GetUserCampaignByIdParams struct {
	ID     int32 `json:"id"`
	UserID int32 `json:"user_id"`
}

type GetUserCampaignByIdRow struct {
	ID            int32     `json:"id"`
	Title         string    `json:"title"`
	Description   *string   `json:"description"`
	Slug          string    `json:"slug"`
	UserID        int32     `json:"user_id"`
	TargetAmount  *float32  `json:"target_amount"`
	CurrentAmount *float32  `json:"current_amount"`
	StartDate     time.Time `json:"start_date"`
	EndDate       time.Time `json:"end_date"`
	Status        int32     `json:"status"`
	CreatedAt     time.Time `json:"created_at"`
	UpdatedAt     time.Time `json:"updated_at"`
}

func (q *Queries) GetUserCampaignById(ctx context.Context, arg GetUserCampaignByIdParams) (GetUserCampaignByIdRow, error) {
	row := q.db.QueryRowContext(ctx, getUserCampaignById, arg.ID, arg.UserID)
	var i GetUserCampaignByIdRow
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Description,
		&i.Slug,
		&i.UserID,
		&i.TargetAmount,
		&i.CurrentAmount,
		&i.StartDate,
		&i.EndDate,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const softDeleteCampaign = `-- name: SoftDeleteCampaign :one
UPDATE campaigns
SET deleted_at = CURRENT_TIMESTAMP
WHERE id = $1 AND user_id = $2
RETURNING id, title, description, slug, user_id, target_amount, current_amount, start_date, end_date, status, created_at, updated_at, deleted_at, images
`

type SoftDeleteCampaignParams struct {
	ID     int32 `json:"id"`
	UserID int32 `json:"user_id"`
}

func (q *Queries) SoftDeleteCampaign(ctx context.Context, arg SoftDeleteCampaignParams) (Campaign, error) {
	row := q.db.QueryRowContext(ctx, softDeleteCampaign, arg.ID, arg.UserID)
	var i Campaign
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Description,
		&i.Slug,
		&i.UserID,
		&i.TargetAmount,
		&i.CurrentAmount,
		&i.StartDate,
		&i.EndDate,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		pq.Array(&i.Images),
	)
	return i, err
}

const updateCampaign = `-- name: UpdateCampaign :one
UPDATE campaigns
SET title = $1, description = $2, slug = $3, target_amount = $4, start_date = $5, end_date = $6, status = $7, updated_at = CURRENT_TIMESTAMP
WHERE id = $8 AND user_id = $9
RETURNING id, title, description, slug, user_id, target_amount, current_amount, start_date, end_date, status, created_at::TIMESTAMP, updated_at::TIMESTAMP
`

type UpdateCampaignParams struct {
	Title        string    `json:"title"`
	Description  *string   `json:"description"`
	Slug         string    `json:"slug"`
	TargetAmount *float32  `json:"target_amount"`
	StartDate    time.Time `json:"start_date"`
	EndDate      time.Time `json:"end_date"`
	Status       int32     `json:"status"`
	ID           int32     `json:"id"`
	UserID       int32     `json:"user_id"`
}

type UpdateCampaignRow struct {
	ID            int32     `json:"id"`
	Title         string    `json:"title"`
	Description   *string   `json:"description"`
	Slug          string    `json:"slug"`
	UserID        int32     `json:"user_id"`
	TargetAmount  *float32  `json:"target_amount"`
	CurrentAmount *float32  `json:"current_amount"`
	StartDate     time.Time `json:"start_date"`
	EndDate       time.Time `json:"end_date"`
	Status        int32     `json:"status"`
	CreatedAt     time.Time `json:"created_at"`
	UpdatedAt     time.Time `json:"updated_at"`
}

func (q *Queries) UpdateCampaign(ctx context.Context, arg UpdateCampaignParams) (UpdateCampaignRow, error) {
	row := q.db.QueryRowContext(ctx, updateCampaign,
		arg.Title,
		arg.Description,
		arg.Slug,
		arg.TargetAmount,
		arg.StartDate,
		arg.EndDate,
		arg.Status,
		arg.ID,
		arg.UserID,
	)
	var i UpdateCampaignRow
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Description,
		&i.Slug,
		&i.UserID,
		&i.TargetAmount,
		&i.CurrentAmount,
		&i.StartDate,
		&i.EndDate,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updatePaymentFromCallback = `-- name: UpdatePaymentFromCallback :one
UPDATE payments
SET 
    status = $2, 
    updated_at = CURRENT_TIMESTAMP,
    vendor = $3,
    method = $4,
    response = $5,
    payment_date = $6
WHERE id = $1
RETURNING id, transaction_id, donatur_id, donation_id, campaign_id, vendor, method, amount, link, note, status, response, payment_date, created_at, updated_at
`

type UpdatePaymentFromCallbackParams struct {
	ID          int32                 `json:"id"`
	Status      int32                 `json:"status"`
	Vendor      sql.NullString        `json:"vendor"`
	Method      sql.NullString        `json:"method"`
	Response    pqtype.NullRawMessage `json:"response"`
	PaymentDate sql.NullTime          `json:"payment_date"`
}

func (q *Queries) UpdatePaymentFromCallback(ctx context.Context, arg UpdatePaymentFromCallbackParams) (Payment, error) {
	row := q.db.QueryRowContext(ctx, updatePaymentFromCallback,
		arg.ID,
		arg.Status,
		arg.Vendor,
		arg.Method,
		arg.Response,
		arg.PaymentDate,
	)
	var i Payment
	err := row.Scan(
		&i.ID,
		&i.TransactionID,
		&i.DonaturID,
		&i.DonationID,
		&i.CampaignID,
		&i.Vendor,
		&i.Method,
		&i.Amount,
		&i.Link,
		&i.Note,
		&i.Status,
		&i.Response,
		&i.PaymentDate,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
